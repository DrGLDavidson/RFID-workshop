---
title: "3. RFID Tutorial: Introduction to RFID data filtering"
author: "Gabrielle Davidson"
date: "2024-08-12"
output: html_document
---
## 1. Get set up

### Open R Studio

### Check R packages installed
```{r echo=T, results='hide', error=FALSE, warning=FALSE, message=FALSE}
#load the following packages
library(tidyverse)
library(rmarkdown)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(stringi) #may not need this
library(magrittr) #may not need this

```
### Download resources necessary for the workshop
Download the resources from **[my github page](https://github.com/DrGLDavidson/TOBEUPDATED)**

## 3.1 import your dataset to your environment from your working directory. 

```{r}

#clear the global environment so we don't have any conflicts with the next steps 

rm(list = ls(all.names = TRUE))

#choose the appropriate working directory

setwd("F:/RWorkspace/GitHub/RFID-workshop/data/feederData")

#call your most recent dataset of merged feeder data. 

df<-read.delim("Masterdf_220209.txt", header=TRUE)
head(df)
names(df)

```

## 3.2 Data filtering

### 3.2.1 Remove misreads (i.e. erroneous TagID_hex values)
# Ocassionally the RFID reader will incorrectly read an tag. This may be because the bird does not properly land on the perch to feed, and so these 'misreads' can be removed. 
# To remove misreads, we need to match the feeder data against known tagged bird IDs (i.e. Passive Integrative Transponder (PIT) tag numbers, aka TagID_hex). I have provided a file with a list of PIT tags and corresponding metadata (species, age, sex etc.). Note this data is NOT from the UEA population. 

```{r}

#upload a list of your known PIT tag IDs. Notice that the file is a .csv, rather than .txt
PIT<-read.csv(file="PITList_tutorial.csv", header=TRUE)
names(PIT)

#note that the ring type (BTO and PIT) refer to whether it was a new bird (first time given the ring), or retrap (already had the ring). It is possible that a bird may already have a BTO ring (R) but not a PIT tag (N). However, in these cases, the code was meant to be A for added (but you can ignore this detail for now). 

#check how many unique PIT tag IDs there are, it should match the number of observations (global environment). If it does not match, it suggests duplicates. Duplicates would matter if you are planning to merge the metadata and you want it to be a particular date (e.g. age of a bird when it was first fitted with a ring)

length(unique(PIT$pitID))

#to merge/match PIT tags from two files you must ensure the header that contains the values of interest are named the same across files. Currently they are not. 

head(PIT)
head(df)

#rename the header in PIT to match that of df
names(PIT)[names(PIT) == "pitID"] <- "TagID_hex"  
names(PIT)

#if we view df, we will also see there are a lot of rows with no TagID_hex. This is because non-tagged birds often land on the feeder and it shows up as a time stamp with no corresponding TagID_hex. Lets remove blank rows, otherwise there will be many rows that can't merge with PIT. 

df <- with(df, df[!(TagID_hex == "" | is.na(TagID_hex)), ])

#Now you can merge dataframes by their shared TagID_hex value. In addition, if there are any missing TagID_hex values from PIT, it will be indicated with "NA". In other words, if a bird that is not on our database was detected at the feeder, it will show up as NA. This code also returns any values from our PIT dataframe that was not on df. In otherwords, an NA is given if the bird on our database was never detected at the feeders. 

df1 <- merge(df, PIT, by = "TagID_hex", all = TRUE)
df1[is.na(df1)] <- "NA"  

#We are only interested in the TagID_hex that was detected at the feeder, but not on our database. We will filter these into a new dataframe called missing. We extract these as values that did not have a BTO 

missing<-df1%>%
  filter(btoID=="NA")

# why do we do this with the header btoRing? Because TagID_hex is now merged across dataframes, so this is no longer informative for missing data. Any of the headers from the PIT dataframe would work, but we are using btoID. 

#there are 54 observations where there is no corresponding PIT tag. 
#create a list of TagID_hex reads that did not have a match: 

uniqueMisreads <- unique(missing$TagID_hex)
uniqueMisreads

#there are two tags. "0300024FEF" is our reference tag. It is the tag that the experimenter uses to test the feeders and mark when experiments start and end. "01103F3B1B" looks like a genuine tag. But is it a misread or missing data from our PIT tag data? To answer this, double check the master ringing database to see if that tag is there. If it is not there, assume it is a misread. If it is there, add it to the PIT database and re-run your code.

#save your misreads for your records

setwd(path)  # insert the correct working directory (path)

write.csv(uniqueMisreads, file="uniqueMisreadsFeeders.csv")

#assuming we have resolved this, merge df and PIT again, using a different code that wont keep all NAs from the PIT file, but will remove NAs from the btoRing column, using the argument all = FALSE

df1 <- merge(df, PIT, by = "TagID_hex", all = FALSE)

#this returns a dataframe that is 1214 observations. 
1268-1214

# this equals 54, which is the same number of observations from our dataframe "missing". This makes sense. 

# Another way you can merge dataframes is using the package dplyr and the following code: 

df2<-left_join(df, PIT ,by ="TagID_hex")

# and then we have to remove NAs with another chunk of code

df2<-df2[!is.na(df2$btoRing),]

write.table(df2, file = "Masterdf_noMisreads.txt",sep="\t",row.names=FALSE) 

```

### 4.2 Filter repetitive RFID reads within a single visit

```{r}
#first we need to make the time column in a time format
class(df2$timeDate)
#it appears that throughout our data wrangling the files have dropped the zero in front of some of the values in the column timeDate, which is the following digits: 2xsec, 2xmin, 2xhour 2xcalendar day, 2xmonth, 2xyear.
#to rectify this, we will create a new column from the chNtimeDate25 column. This may not be relevant to your RFID output
names(df2)[names(df2) == "timeDate"] <- "oldtimeDate" 
df2$chNtimeDate<-str_replace_all(df2$chNtimeDate,fixed(" "), "")  ###remove spaces
df2$timeDate<-substring(df2$chNtimeDate, nchar(as.character(df2$chNtimeDate))- 11) 
# Extract information for year, month, day etc. from timeDate column
df2$year <- stri_sub(df2$timeDate,-2,-1)
df2$year <- paste(df2$year,'20', sep='')
df2$month <- stri_sub(df2$timeDate,-4,-3)
df2$day <- stri_sub(df2$timeDate,-6,-5)
df2$hour <- as.numeric(stri_sub(df2$timeDate,5,6))
df2$min <- as.numeric(stri_sub(df2$timeDate,3,4))
df2$sec <- as.numeric(stri_sub(df2$timeDate,1,2))
df2$date <- paste(df2$year, df2$month, df2$day, sep='-')
df2$time <- paste(df2$hour, df2$min, df2$sec, sep=':')
df2$datetime <- as.POSIXct(paste(df2$date, df2$time), format="%Y-%m-%d %H:%M:%S")
class(df2$datetime)

 

```
```{r, warning=FALSE}
#create a column that calculates the time difference with previous row of a dataframe grouped by date, feeder and RFID

df3<-df2 %>%
  arrange(datetime)%>%
  group_by(date, feeder, RFID) %>%
  mutate(timeSincePreviousVisit = datetime - lag(datetime))%>%
  arrange(RFID, feeder, date)%>%
  ungroup()%>%
  select(feeder,RFID,date, datetime, timeSincePreviousVisit)

#lets look at the output of just those selected columns to see we have produced what we think we want
#0 sec was calculated if the bird was on the feeder within the same seconds
#NA is given if it is the birds' first visit of the day

#rerun the above code without the select() argument

df3<-df2 %>%
  arrange(datetime)%>%
  group_by(date, feeder, RFID) %>%
  mutate(timeSincePreviousVisit = datetime - lag(datetime))%>%
  arrange(RFID, feeder, date)%>%
  ungroup()

##the new column timeSincePreviousVisit has "sec" and we don't want that, so lets remove it

df3$timeSincePreviousVisit <- gsub(' sec', '', df3$timeSincePreviousVisit)

#the column timeSincePreviousVisit needs to be numeric for graphical purposes and for filtering based on greater than/less than values

df3$timeSincePreviousVisit <- as.numeric(as.character(df3$timeSincePreviousVisit)) 
class(df3$timeSincePreviousVisit)

#create a dataframe of successive visits that are less than 20 seconds so we can graph how frequently birds are read at the feeder
#use the "select" argument to extract only the column named timesSincePreviousVisit
df4<-df3%>%
  filter(timeSincePreviousVisit <=20)%>%
  select(timeSincePreviousVisit)
class(df4$timeSincePreviousVisit)


#cumulative frequency graph
ggplot(df4, aes(timeSincePreviousVisit, y= 1-..y..))+
  stat_ecdf(geom = "step", color="purple")
#histogram
ggplot(df4, aes(x=timeSincePreviousVisit)) +geom_histogram(binwidth = 1) 

#it appears that visit frequency drops after 1 second and there are a small fraction that occur after 2 and 3 seconds. 
#Most of the literature does a cut off at 2 or 3 seconds. 

#Filter dataset to remove visits that were within 1-2 seconds of eachother

#note that there are NAs because it was the first visit of the day so we can replace that with 'firstVisit'
df3$timeSincePreviousVisit[is.na(df3$timeSincePreviousVisit)] <- 'firstVisit' 


df5<-df3%>%
  filter(timeSincePreviousVisit=='firstVisit')

df6<-df3%>%
  filter(timeSincePreviousVisit>2)
#we need to make the column timeSincePreviousVisit a character back from numerical in order to bind with df5, which is a character string
df6$timeSincePreviousVisit <- as.character(df6$timeSincePreviousVisit)

df7<-bind_rows(df5,df6)%>%
  arrange(RFID,feeder,date)


write.table(df7, file = "filteredVisitsFeeders.txt",sep="\t",row.names=FALSE)
```
## 4.3 cleanup dataframe and save it
The current dataframe has some columns that are redundant and the format of the column headers aren't the same
```{r}
#before we do this, lets save the file as it is now

write.table(df7, file = "filteredVisitsFeeders.txt",sep="\t",row.names=FALSE)

#check the column names
names(df7)
#SPEC and SEX are not in our typical format, so lets change the names of the columns to match our syntax

#change the column
names(df7)[names(df7) == "SEX"] <- "sex"  
names(df7)[names(df7) == "SPEC"] <- "species"  

#we dont need "oldtimeDate" or "timeDate" anymore
#we can also rearrange the order of the columns

df7<-df7%>%
  select(chNtimeDate, chNtimeDate25, TagID_Hex, RFID, btoRing, species, sex, dateFirstCaptured, ageFirstCaptured, feeder, year, month, day, hour, min, sec, date, time, datetime, timeSincePreviousVisit )

write.table(df7, file = "filteredVisitsFeeders.txt",sep="\t",row.names=FALSE)
```


### 4.4 Dealing with RFID malfunction

```{r}
#Check for periods of missing data
#we have a dataframe with time since previous visit grouped by individual and by date. We would expect big time gaps across all individuals if a feeder was down. 
df7$timeSincePreviousVisit <- as.numeric(as.character(df7$timeSincePreviousVisit)) 
hist(df7$timeSincePreviousVisit)
min(df7$timeSincePreviousVisit)
#this gives us a value of NA - this is because there are NAs in the document, so we need to add an argument to ignore these. 
min(df7$timeSincePreviousVisit, na.rm = TRUE)
max(df7$timeSincePreviousVisit, na.rm = TRUE)
mean(df7$timeSincePreviousVisit, na.rm = TRUE)
median(df7$timeSincePreviousVisit, na.rm = TRUE)
#how many seconds in a day?
24*60*60
#daylight hours?
16*60*60
```
There doesn't appear to be any obvious indication that any of the feeders were down.

But maybe a feeder was down for an entire day, and since we filtered by day, there wouldn't be large periods of no visits. 

```{r}
#first lets see how many days we have data for
unique(df7$date)

#is this true for all feeders?

F01<-df7%>%
  filter(feeder=='feeder01')
unique(F01$date)

F02<-df7%>%
  filter(feeder=='feeder02')
unique(F02$date)

F03<-df7%>%
  filter(feeder=='feeder03')
unique(F03$date)
#we can see that feeder03 did not collect data on 2020-01-20, 2020-01-23, 2020-01-24

```

Imagine we decided we want to remove data from feeders that were working but overlapped with a time that another was not working, perhaps because they are highly dependent on eachother
```{r}
#remove rows that meet the conditions of having the following dates in the column "date"
df8<-df7[!(df7$date=="2020-01-20" |df7$date=="2020-01-23" |df7$date=="2020-01-24" ),]
#check that worked
unique(df8$date)
```
How to deal with missing data depends on the experiment and analysis. 

Examples:

- For social network analysis, the Machine Learning algorithms workout flocking events from the streams of data over periods of weeks and therefore these analyses are less sensitive to malfunctions, provided you have sufficient periods when the feeders are working

- If you were calculating frequency of nestbox visits per day, and the device failed part of the day, then you would consider not including it that day, or correcting for malfunction time (e.g. frequncy per hour, not by day, or corrected for hours working)

- If you had a learning experiment where birds had access to one out of an array of feeders, the following is what we did for our analysis: *We therefore included the duration of feeder malfunction before the bird reached learning criterion for both the assigned (own) feeder and separately for any of the other feeders in that site as additional fixed effects. Reichert et al 2020 RSOS*

An alternative approach would be to add a column for each feeder and indicate whether it had malfunctioned for each row. 
```{r }

df8<-df7%>%
  mutate(feeder03Malf = case_when(date =='2020-01-20' ~'Y', 
                                  date =='2020-01-23'~'Y' , 
                                  date =='2020-01-24'~'Y'))


```
## 5 Data visualisation and extraction

### 5.1 total number and proportion of visits
```{r}
#a new dataframe that counts the total number of visits per feeder per individual, per date. 
individualvisits<-df7%>%
  count(feeder, RFID, date, sort = TRUE) 

#a new dataframe that counts the proportion an individual visits a feeder relative to the other feeders, per day. 
ProportionVisits<-individualvisits%>%
  group_by(RFID, date)%>%
  arrange(RFID)%>%
  mutate(freq = n / sum(n))%>%
  ungroup() 

```
### **5.1 EXERCISE** 
- Create a dataframe of the total individual visits across the whole of your experiment, irrespective of feeder

- Create a new dataframe that excludes individuals that visited less than 50 times (i.e. participation threshold censu Reichert et al 2020 RSOS) 

- rename the column of the number of visits to "totalVisits"

- plot a histogram of the number of visits from your new dataframe with an appropriate bar width

- create a dataframe with a list of birds we consider participants and save it as a csv file
```{r  }

#5.1 exercise answer
#a new dataframe that counts the total number of visits per individual. 
individualvisits2<-df7%>%
  count(RFID, sort = TRUE) 

individualvisits3<-individualvisits2%>%
  filter(n >50)%>%
  select(RFID,n)

#change the column
names(individualvisits3)[names(individualvisits3) == "n"] <- "totalVisits"  

ggplot(individualvisits3, aes(x=totalVisits)) +geom_histogram(binwidth = 20) 

participants <- unique(individualvisits3$RFID)

participants<-as.data.frame(participants)
#write.csv(participants, file="FeederExperimentParticipants.csv"))

```

### 5.2 how many RFID devices an individual visits
```{r}
# check how many feeders each individual visited
IDFeeder<-df7%>%
  count(feeder, RFID, sort = TRUE) 
IDFeeder<-IDFeeder%>%
  count(RFID, sort = TRUE) 
summary(IDFeeder$n)
boxplot(IDFeeder$n)

##this may also be particularly useful for a nestbox population to see how many other nestboxes individuals visit
```
### 5.3 EXERCISE - Time intervals between visits among individuals

Previously we created a column that indicated how many seconds had passed since an individual's previous visit per day. A similar approach can be taken to calculate intervals between visits between individuals (i.e. how long has passed since the previous birds' visit)

- clear your global environment

- reload your database "filteredVisitsFeeders.txt"

- change the datetime column to be a POSIXct class 

- create a new column that calculates the time difference from the previous row of a dataframe grouped by date and feeder. Dont forget to use the argument arrange() so the timedate is sequential in your dataframe

- create a dataframe consisting of individuals that visited a feeder equal or less than 1 second after the previous visitor, perhaps this suggests they are more likely to displace other birds from the feeder. 

- create a dataframe of a list of unique individuals that have landed on a feeder within 1 second of the previous visitor

- create a dataframe that counts the number of times each individual has landed on a feeder within 1 second of the previous visitor


```{r}
#clear global environment
rm(list = ls(all.names = TRUE))

#upload file 

df<-read.table(file="filteredVisitsFeeders.txt", sep="\t", header=TRUE)
names(df)
# change datetime column to be POSIXct class
class(df$datetime)
df$datetime <- as.POSIXct(df$datetime)
class(df$datetime)

df1<-df %>%
  arrange(datetime)%>%
  group_by(date, feeder) %>%
  mutate(timeBetweenID = datetime - lag(datetime))%>%
  arrange(datetime)%>%
  ungroup()

df1$timeBetweenID <- as.numeric(as.character(df1$timeBetweenID)) 
class(df1$timeBetweenID)

df2<-df1%>%
  filter(timeBetweenID <=1)

uniqueDisplacers<-unique(df2$RFID)
uniqueDisplacers<-as.data.frame(uniqueDisplacers)

individualDisplacements<-df2%>%
  count(RFID, sort = TRUE) 

```

### 5.4 EXERCISE - Correct and incorrect visits

Imagine feeder01 is rewarded and feeder02 and feeder03 are not rewarded. How would you include a column called "correctChoice" where visits to feeder01 contain the character "Y" and visits to the incorrect feeders contain the character "N"
```{r}

df7<-read.table(file="filteredVisitsFeeders.txt", sep="\t", header=TRUE)

F01Y<-df7%>%
  filter(feeder=='feeder01')
F01Y<-cbind(F01Y, correctChoice='Y')

F02N<-df7%>%
  filter(feeder=='feeder02')
F02N<-cbind(F02N, correctChoice='N')

F03N<-df7%>%
  filter(feeder=='feeder03')
F03N<-cbind(F03N, correctChoice='N')

df7<-bind_rows(F01Y, F02N, F03N)

#Note that there are other methods, but this method uses approaches we learned in today's workshop. As you enhance your R coding skills you'll inevitably refine your code. 

```


# END OF FEEDER RFID TUTORIAL 

```{r}
sessionInfo()
```

