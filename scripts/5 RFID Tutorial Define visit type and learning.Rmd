---
title: '5. RFID Tutorial: Define visit type and learning'
author: "Gabrielle Davidson"
date: "2024-08-16"
output: html_document
---
## 5. Get set up

### Open R Studio

### Check R packages installed
```{r echo=T, results='hide', error=FALSE, warning=FALSE, message=FALSE}
#load the following packages
library(tidyverse) #some of the packages below are included in tidyverse
library(rmarkdown)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(stringi) 
library(magrittr) #may not need this

# These are new and need to be installed 
library(writexl)
library(readxl)
library(zoo) #rolling function

```
### Download resources necessary for the workshop
Download the resources from **[my github repository](https://github.com/DrGLDavidson/RFID-workshop)**

### 5.1 import your dataset to your environment from your working directory. 

```{r}

#clear the global environment so we don't have any conflicts with the next steps 

rm(list = ls(all.names = TRUE))

#choose the appropriate working directory

setwd("F:/RWorkspace/GitHub/RFID-workshop/data/outputFiles")

#call your most recent dataset 

df<-read.delim("Masterdf_noRepeats.txt", header=TRUE)
head(df)
names(df)

```

### 5.2 Quantifying correct and incorrect visits (i.e. if a bird landed on its assigned feeder according to ListA logic)

```{r echo=T, results='hide', error=FALSE, warning=FALSE, message=FALSE}

#how many individual tags (birds) in our dataset
length(unique(df$TagID_hex)) 

#in practice, you will have (or create) a file for each bird indicating which feeder opens for which bird. This is often referred to as "ListA" because this is what the logic is called in the logger.ini file associated with the computerised feeder.  

#For the purpose of this tutorial, we create a random vector of data to indicate which feeder opens for a given bird. Draw 44 samples from the integers 1:3 with replacement (i.e. each number can be redrawn), and attach that to unique bird IDs. 
assignedFeeder<-sample(x = 1:3, size = 44, replace = TRUE)
#unique birds in df
TagID_hex<-unique(df$TagID_hex)

df2<-cbind(TagID_hex, assignedFeeder)
df2<-as.data.frame(df2)

#change values in assignedFeeder to match feeder values in df. 

df3 <- df2 %>%
  mutate(assignedFeeder = recode(assignedFeeder,
                           "1" = "F01",
                           "2" = "F02",
                           "3" = "F03"))

df4 <- merge(df, df3, by = "TagID_hex", all = TRUE)

#create a vector of whether values in df4$feeder are identical to df4$assignedFeeder and return TRUE or FALSE
correctVisit <- c()
for (i in 1:nrow(df4)) {
  correctVisit[i] <- identical(df4$feeder[i], df4$assignedFeeder[i])
}

#add the vector to df4
df4$correctVisit <- correctVisit

#create a binary variable column for downstream statistical analyses and figures

df4$correctVisit<-as.character(df4$correctVisit)

df5 <- df4 %>%
  mutate(correctVisitBinary = recode(correctVisit,
                           "TRUE" = "1",
                           "FALSE" = "0"))


write.table(df5, file = "Masterdf_correctVisits.txt",sep="\t",row.names=FALSE)


```

### 5.3 Quantifying learning (i.e. if a bird visits its assigned feeder at a given criterion).
## In this example, we will use the criterion of 80% correct visits, across a minimum of 20 visits. 

```{r echo=T, results='hide', error=FALSE, warning=FALSE, message=FALSE}
#filter out birds that have visited at least 20 times

df20 <- df5 %>%
  group_by(TagID_hex) %>%
  mutate(visit_count = n()) %>%  #what variable is visit count
  filter(visit_count >= 20) %>%
  ungroup() %>%
  select(-visit_count) 

#function for when criterion met first
success_check <- function(correct ){
  n <- length(correct)  #what variable is correct
 if (n < 20){
   return(NA)
 }
  for (i in 1:(n-19)) {
    window <- correct[i: (i+ 19)]
    if(window[1] == 1 && sum(window)/ 20 >= 0.8){
      return(i+19)
    }
    
  }
  return(NA)
}

#### birds visiting >20 ####

#apply criterion check function
results20 <- df5 %>% 
  group_by(TagID_hex) %>% 
  summarise(criterion = success_check(correctVisit))  ##what is success_check?
head(results20) #function works well 

```


# END OF 5. RFID Tutorial: Define visit type and learning