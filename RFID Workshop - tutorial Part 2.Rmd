---
title: "RFID Workshop - tutorial Part 2"
author: "Gabrielle Davidson"
date: "2023-04-18"
output: html_document
---
## 1. Get set up

### Open R Studio

### Check R packages installed
```{r echo=T, results='hide', error=FALSE, warning=FALSE, message=FALSE}
#load the following packages
library(tidyverse)
library(rmarkdown)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(stringi)
library(magrittr)

```
### Download resources necessary for the workshop
Download the resources from **[my github page](https://github.com/DrGLDavidson/RFID-workshop)**

## 2. Nestbox data 

### 2.1 data cleanup

```{r}

#set working directory so R knows where to find and save data
setwd("F:/RWorkspace/RFIDworkshop/nestboxData")

#load an RFID file taken from a nest boxes during the breeding season
df1<-read.delim(file="C1254RT.txt", sep="\t", header=TRUE)  
names(df1)

#create new dataframes that include only the columns Date, Hmsec, CounterID , dur.ms, TagID_1

df1<-df1%>%
  select(Date, Hmsec, CounterID, TagID_1)
names(df1)

#change the TagID_1 column to RFID which we are familiar with using
names(df1)[names(df1) == "TagID_1"] <- "RFID"  

uniqueIDs<-unique(df1$RFID)
uniqueIDs

#remove rows that contain the value "TagID_1" which appear as erroneous headers throughout the dataframe

df1<-df1[!grepl('TagID_1', df1$RFID),]

#remove blank rows 
df1<-df1[!df1$RFID=="",]

```
## 2.2 data exploration
```{r}
uniqueIDs<-unique(df1$RFID)
uniqueIDs

#tag 0300030EFF is a 'reference tag' used by the experimenter to indicate the start of when the RFID was put up on the nestbox. This can be useful for parent identification (e.g. swapping across nests throughout the day just to see who is there, with an accompanying note book to indicate the time that each nest received the RFID), or for indicating the start of an experiment. 

referenceTag<-df1[df1$RFID == '0300030EFF',]
referenceTag

#we can see it was read 3 times and was on the box for 3 hours, 6 minutes and 5 seconds. 

#change the Date column into a POSIXct class
df1<-df1%>%
  mutate(Date=ymd_hms(Date))
class(df1$Date)



```
### **EXERCISE 2.2 Nestbox visit frequencies 
- create a dataframe with the total number of visits per RFID 
- create a new column called "BtwVisitInterval" that indicates the time since the previous visit, irrespective of RFID
- create a new column called "WtnVisitInterval" that indicates the time since the previous visit grouped by RFID
- save the file as "C1254RT_visitIntervals.txt"
- clear your working environment

```{r, echo=FALSE}
totalVisits<-df1%>%
  count(RFID, sort = TRUE) 


df1<-df1%>%
  arrange(Date)%>%
  mutate(BtwVisitInterval = Date - lag(Date, default=first(Date)))

df1<-df1%>%
  group_by(RFID)%>%
  arrange(Date)%>%
  mutate(WtnVisitInterval = Date - lag(Date, default=first(Date)))%>%
  arrange(RFID)%>%
  ungroup()

write.table(df1, file = "C1254RT_visitIntervals.txt",sep="\t",row.names=FALSE) 

rm(list = ls(all.names = TRUE))

```
## 2.3 visit frequency summaries

```{r}
#load the file C1254RT_visitIntervals.txt

df1<-read.delim(file="C1254RT_visitIntervals.txt", sep="\t", header=TRUE)  
names(df1)

#change the Date column into a POSIXct class
df1<-df1%>%
  mutate(Date=ymd_hms(Date))
class(df1$Date)

boxplot(df1$WtnVisitInterval~df1$RFID)

#this graph is not scaled properly because of the long visit between the reference tag, so lets make a temporary dataframe that excludes the reference tag. 

df2<-df1[!grepl('0300030EFF', df1$RFID),]

boxplot(df2$WtnVisitInterval~df2$RFID)
mean(df2$WtnVisitInterval)
min(df2$WtnVisitInterval)
max(df2$WtnVisitInterval)

#look at this as a histogram - perhaps we need to filter out reads that occur within X number of seconds. 
ggplot(df2, aes(x=WtnVisitInterval)) +geom_histogram(binwidth = 1) 

#zoom in
ggplot(df2, aes(x=WtnVisitInterval)) +geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 60))

#zoom in more
ggplot(df2, aes(x=WtnVisitInterval)) +geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 25))

#zoom in even more
ggplot(df2, aes(x=WtnVisitInterval)) +geom_histogram(binwidth = 1) +
  scale_x_continuous(limits = c(0, 5))

```
It appears as though the tag could be read as two visits if detected within 2 seconds, so we have a good justification to merge visits that are less than 2 seconds. 

Looking at the output of our interval calculation, a value of "0" is the first visit of the day. This doesn't appear as an NA because we did not filter by date this time, like we did with the feeder data. 

Another consideration is that birds have to move in and out of the nest box, and that can occur very quickly, or the parent may stay inside for some time. 

NatureCounters have RFID nestbox fronts that also have photodiodes which can detect the direction of the bird as is passes and logs onto a separate output file whether the event was an "enter" or "exit". 

Another consideration is that in neophobia experiments, from personal observations, birds will perch at the nestbox for a very long time before entering, or leaving the box without entering, and you cannot know if the bird left the box, or entered it. Weary birds will often land and leave the nest box multiple times before overcoming their fear and entering the box. 

Moving forward, lets assume that every time a bird is detected at the box, they have entered, or that your criteria for latency to return to the box is landing on it, not necessarily entering it. 

```{r}
#extract the first occurrence of each RFID tag

latency<-df1%>%
  arrange(Date)%>%
  group_by(RFID)%>%
  slice(1)%>%
  ungroup()

#this gives us a dataframe with the first occurance of each tag, including the reference tag. But remember from earlier the tag was read twice at the start of the experiment, so we want the 2nd reading, not the first

referenceTag<-df1[df1$RFID == '0300030EFF',]
referenceTag


#we want the second row:

df2<-slice(referenceTag, 2)
df2

#remove 0300030EFF from dataframe latency, and bind df2 to latency

latency<-latency[-c(1),]
latency


latency2<-bind_rows(df2, latency)
names(latency)
#date is the first column

#create a column 'latency' where the date of each row is subtrated from the first row
latency3<-latency2%>%
  mutate(latency = Date - Date[row_number()==1])


#can we do this from full dataframe? 

latency4<-df1%>%
  arrange(Date)%>%
  mutate(latency = Date - Date[row_number()==2])%>%
  group_by(RFID)%>%
  slice(1)%>%
  ungroup()



```

## 2.4 filter your data to be wtihin range of dates/times
We know from our referenceTag dataframe that the experiment started at  2019-05-01 10:12:16

But what if we had an experiment that was meant to be 1 hour in length and we wanted to know the visit frequency within that discrete time interval. 

```{r}

#two ways: 
# Extract hours, minutes & seconds
df1$Time <- format(as.POSIXct(df1$Date),   
                 format = "%H:%M:%S")


df2<-subset(df1,Time<='11:12:16' & df1$Time >= '10:12:16') 

#or from the Date column 

df2<-subset(df1,Date <= as.POSIXct('2019-05-01 11:12:16', tz="UTC")) 

df2<-subset(df2,Date >= as.POSIXct('2019-05-01 10:12:16', tz="UTC")) 
                       
totalVisits1hr<-df2%>%
  count(RFID, sort = TRUE) 

```


# END OF FEEDER RFID TUTORIAL 

```{r}
sessionInfo()
```



